# Copilot Instructions for Qnflmty Development

## Project Overview
You are working on **Qnflmty**, a Next.js sports prediction application with the following key characteristics:

- **Framework**: Next.js 15 with TypeScript and App Router
- **Database**: PostgreSQL with Drizzle ORM (`src/server/db/schema.ts`)
- **Authentication**: NextAuth.js (`src/lib/auth.ts`)
- **UI**: Radix UI components with Tailwind CSS
- **Testing**: Cypress for E2E testing
- **Architecture**: Server components with server actions for mutations

## Core Patterns to Follow

### 1. File Structure Conventions
- **Pages**: Use `src/app` directory with `page.tsx` files
- **Components**: Organize in `src/components` with feature-based folders
- **Server Logic**: Place in `src/server` with separate `queries.ts` and `mutations.ts`
- **Database**: Use `src/server/db/schema.ts` for all schema definitions

### 2. Database Patterns
- Use Drizzle ORM with the existing schema from `src/server/db/schema.ts`
- Follow the established relationships: `users` → `userAccounts` → `memberships` → `groups` → `tournaments` → `sports`
- Use the existing helper functions like those in `src/server/admin/queries.ts`

### 3. Authentication & Authorization
- Use `auth()` for session management
- Follow the admin authorization pattern from `src/server/admin/mutations.ts` using `adminAuth()`
- Implement profile selection using the pattern in `src/components/profile-switcher.tsx`

### 4. UI Component Patterns
- Use existing UI components from `src/components/ui`
- Follow the sidebar layout pattern from `src/components/sidebar/app-sidebar.tsx`
- Use the data table pattern from `src/components/ui/data-table` for list views
- Follow the column definition pattern from files like `src/app/admin/sports/columns.tsx`

### 5. Form Handling
- Use server actions for form submissions (see `src/server/admin/mutations.ts`)
- Implement error handling with `fromErrorToFormState` pattern
- Use Zod for validation schemas
- Follow the form pattern from `src/components/profile/profile-creation-form.tsx`

## Feature Development Guidelines

### For Admin Features (Admin Dashboard)
When working on admin features from the TODO list:

1. **List Views**: 
   - Create columns file like `src/app/admin/sports/columns.tsx`
   - Use the data table pattern with bulk actions
   - Follow the pattern from `src/app/admin/users/columns.tsx`

2. **Detail Views**:
   - Create `[id]/page.tsx` for overview pages
   - Include action buttons and tabs for related data
   - Use the user detail pattern from `src/app/admin/users/[id]/page.tsx`

3. **Forms**:
   - Create separate `new/page.tsx` and `[id]/edit/page.tsx`
   - Use server actions for mutations
   - Follow validation patterns with proper error handling

4. **Bulk Actions**:
   - Create separate components like `src/app/admin/users/bulk-suspend.tsx`
   - Use confirmation dialogs for destructive actions

### For User Features (Dashboard)
When working on user-facing features:

1. **Profile Management**:
   - Follow patterns from `src/components/profile`
   - Use the avatar system from `src/lib/avatar-icons.ts`

2. **Request Access**:
   - Follow the pattern from `src/app/request-access/[username]/page.tsx`
   - Use the request system from `src/server/user/queries.ts`

## Testing Patterns
- Write E2E tests in `cypress/e2e/app`
- Use the task system from `cypress/tasks/index.ts` for test data setup
- Follow the test patterns from existing files like `cypress/e2e/app/admins/users.cy.ts`

## Common Code Patterns

### Server Actions
```typescript
export const createSomething = adminAuth(
  async (_initialState: unknown, formData: FormData) => {
    try {
      const data = schema.parse(Object.fromEntries(formData))
      await db.insert(table).values(data)
    } catch (error) {
      return fromErrorToFormState(error)
    }
    redirect('/admin/somewhere')
  }
)
```

### Data Table Columns
```typescript
export const columns: ColumnDef<TableType>[] = [
  {
    id: 'select',
    header: ({ table }) => <Checkbox {...} />,
    cell: ({ row }) => <Checkbox {...} />,
  },
  {
    accessorKey: 'name',
    header: ({ column }) => <DataTableColumnHeader column={column} title="Name" />,
  },
  {
    id: 'actions',
    cell: ({ row }) => <DropdownMenu>...</DropdownMenu>,
  },
]
```

### Navigation Structure
- Use the navigation pattern from `src/components/nav-main.tsx`
- Follow the sidebar structure from `src/components/sidebar/app-sidebar.tsx`

## Key Files to Reference
- **Database Schema**: `src/server/db/schema.ts`
- **Authentication**: `src/lib/auth.ts`
- **Admin Patterns**: `src/server/admin/mutations.ts`, `src/server/admin/queries.ts`
- **UI Components**: `src/components/ui`
- **Data Tables**: `src/components/ui/data-table`
- **Cypress Tasks**: `cypress/tasks/index.ts`

## Priority TODO Items to Focus On
Based on the README.md, prioritize:
1. Admin Groups management (edit, overview, members)
2. Admin Users management (memberships, requests)
3. User dashboard features (picks, leaderboard)
4. Tournament data management

## Development Rules
When implementing any feature, always:
- Follow the existing patterns shown in this codebase
- Include proper TypeScript types
- Add appropriate error handling
- Write corresponding Cypress tests
- Use the established UI components and styling
- Use server actions for mutations
- Follow the authentication patterns
- Include at least 3-5 lines of context when editing files
- Test your changes thoroughly before committing

## Database Relationships to Understand
- Users can have multiple UserAccounts (profiles)
- UserAccounts can have multiple Memberships in different Groups
- Groups belong to a Tournament
- Tournaments belong to a Sport
- Groups have weeks and picks for predictions
- Users can request access to join Groups

## Authentication Flow
1. User logs in with NextAuth
2. User selects/creates a profile (UserAccount)
3. User can request access to join groups
4. Admin can approve/deny requests
5. Users with active memberships can make picks

## Component Architecture
- Use server components by default
- Use client components only when needed for interactivity
- Keep state management simple with React hooks
- Use the established UI component library
- Follow the layout patterns for consistent UX